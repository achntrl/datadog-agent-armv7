From 7c913aa53388a426ae7dbff158d2b9cc49f5a78c Mon Sep 17 00:00:00 2001
From: Adrien Kohlbecker <adrien.kohlbecker@gmail.com>
Date: Mon, 15 Oct 2018 16:51:29 +0100
Subject: [PATCH] Don't use atomic 64 bit variants

On 32 bits system like armv7 (raspberry pi), using `atomic.AddInt64` (and other variants of atomic with 64 bits integer) resulted in a nil pointer exception. https://github.com/golang/go/issues/599

This is only used for logging and assuming an increment each second would overflow in 70 years if 32 bits, so is probably safe
---
 agent/collector.go | 14 +++++++-------
 1 file changed, 7 insertions(+), 7 deletions(-)

diff --git a/agent/collector.go b/agent/collector.go
index d54f070..83bd4b1 100644
--- a/agent/collector.go
+++ b/agent/collector.go
@@ -31,14 +31,14 @@ type Collector struct {
 	cfg           *config.AgentConfig
 	httpClient    http.Client
 	groupID       int32
-	runCounter    int64
+	runCounter    int32
 	enabledChecks []checks.Check
 
 	// Controls the real-time interval, can change live.
 	realTimeInterval time.Duration
 	// Set to 1 if enabled 0 is not. We're using an integer
 	// so we can use the sync/atomic for thread-safe access.
-	realTimeEnabled int64
+	realTimeEnabled int32
 }
 
 // NewCollector creates a new Collector
@@ -71,7 +71,7 @@ func NewCollector(cfg *config.AgentConfig) (Collector, error) {
 }
 
 func (l *Collector) runCheck(c checks.Check) {
-	runCounter := atomic.AddInt64(&l.runCounter, 1)
+	runCounter := atomic.AddInt32(&l.runCounter, 1)
 	s := time.Now()
 	// update the last collected timestamp for info
 	updateLastCollectTime(time.Now())
@@ -139,7 +139,7 @@ func (l *Collector) run(exit chan bool) {
 			for {
 				select {
 				case <-ticker.C:
-					realTimeEnabled := atomic.LoadInt64(&l.realTimeEnabled) == 1
+					realTimeEnabled := atomic.LoadInt32(&l.realTimeEnabled) == 1
 					if !c.RealTime() || realTimeEnabled {
 						l.runCheck(c)
 					}
@@ -212,7 +212,7 @@ func (l *Collector) postMessage(checkPath string, m model.MessageBody) {
 }
 
 func (l *Collector) updateStatus(statuses []*model.CollectorStatus) {
-	curEnabled := atomic.LoadInt64(&l.realTimeEnabled) == 1
+	curEnabled := atomic.LoadInt32(&l.realTimeEnabled) == 1
 
 	// If any of the endpoints wants real-time we'll do that.
 	// We will pick the maximum interval given since generally this is
@@ -229,10 +229,10 @@ func (l *Collector) updateStatus(statuses []*model.CollectorStatus) {
 
 	if curEnabled && !shouldEnableRT {
 		log.Info("Detected 0 clients, disabling real-time mode")
-		atomic.StoreInt64(&l.realTimeEnabled, 0)
+		atomic.StoreInt32(&l.realTimeEnabled, 0)
 	} else if !curEnabled && shouldEnableRT {
 		log.Info("Detected active clients, enabling real-time mode")
-		atomic.StoreInt64(&l.realTimeEnabled, 1)
+		atomic.StoreInt32(&l.realTimeEnabled, 1)
 	}
 
 	if maxInterval != l.realTimeInterval {
-- 
2.17.0

